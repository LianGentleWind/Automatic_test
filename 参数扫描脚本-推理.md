File: automatic/analyze_results.py
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
结果分析脚本
功能：读取所有CSV结果文件，提取关键指标，生成汇总分析表格
"""

import os
import csv
import gzip
from pathlib import Path

from common import load_yaml_config, setup_logging, generate_param_name_from_path, CONFIG_YAML_PATH

# ==================== CSV解析 ====================
def parse_transposed_csv(csv_file, logger):
    """
    解析转置格式的CSV文件（支持gzip压缩）
    
    Args:
        csv_file: CSV文件路径
        logger: 日志对象
    
    Returns:
        dict: 解析后的数据，结构为 {field_name: [values]}
    """
    # 支持gzip压缩
    opener = gzip.open if csv_file.endswith('.gz') else open
    mode = 'rt' if csv_file.endswith('.gz') else 'r'
    
    data = {}
    
    try:
        with opener(csv_file, mode, encoding='utf-8') as f:
            reader = csv.DictReader(f)
            
            for row in reader:
                field_name = row.get('field_name', '')
                
                if not field_name:
                    continue
                
                # 提取所有run的值
                values = []
                for key in sorted(row.keys()):
                    if key.startswith('run_'):
                        values.append(row[key])
                
                data[field_name] = values
        
        logger.info(f"成功解析CSV文件: {csv_file}, 字段数: {len(data)}")
    
    except Exception as e:
        logger.error(f"解析CSV文件失败: {csv_file}, 错误: {str(e)}")
        raise
    
    return data

# ==================== 参数值提取 ====================
def extract_param_value_from_filename(filename, param_name):
    """
    从配置文件名中提取参数值
    
    Args:
        filename: 文件名，如 runtime_mem1_GiB_50.json 或对应的CSV文件名
        param_name: 参数名称，如 mem1_GiB
    
    Returns:
        str or None: 参数值，如 50
    """
    # 移除扩展名
    name_without_ext = os.path.splitext(filename)[0]
    
    # 查找参数名称和值
    # 格式: {prefix}_{param_name}_{value}
    parts = name_without_ext.split('_')
    
    # 查找param_name的位置
    param_parts = param_name.split('_')
    param_len = len(param_parts)
    
    for i in range(len(parts) - param_len):
        if parts[i:i+param_len] == param_parts:
            # 找到参数名称，下一个应该是值
            if i + param_len < len(parts):
                return parts[i + param_len]
    
    return None

def extract_param_from_csv_data(csv_data, param_name):
    """
    从CSV数据中提取参数值
    
    Args:
        csv_data: 解析后的CSV数据
        param_name: 参数名称，如 mem1_GiB
    
    Returns:
        str or None: 参数值
    """
    # 将param_name转换为可能的字段名
    # mem1_GiB -> mem1.GiB 或 GiB
    field_name = param_name.replace('_', '.')
    
    # 尝试多种可能的字段名
    possible_names = [
        field_name,
        param_name,
        field_name.split('.')[-1],  # 只取最后一部分
    ]
    
    for name in possible_names:
        if name in csv_data:
            values = csv_data[name]
            if values and len(values) > 0:
                return values[0]  # 返回第一个值
    
    return None

# ==================== 结果分析 ====================
def analyze_results(results_dir, param_name, output_file, key_fields, logger):
    """
    分析所有结果并生成汇总表格
    
    Args:
        results_dir: 结果目录
        param_name: 参数名称（用于从文件名提取）
        output_file: 输出文件路径
        key_fields: 需要提取的关键字段列表
        logger: 日志对象
    """
    logger.info(f"开始分析结果，目录: {results_dir}")
    
    # 扫描所有CSV文件
    csv_files = []

    # 目标文件优先级列表
    TARGET_FILES = [
        "pd-split-request-optimal_result_best.csv",
        "pd-split-request-optimal_decoder_best.csv",
        "pd-split-request-optimal_prefill_best.csv"
    ]

    for root, dirs, files in os.walk(results_dir):
        # 按优先级顺序查找目标文件
        target_found = None
        for target in TARGET_FILES:
            if target in files:
                target_found = os.path.join(root, target)
                break
            elif f"{target}.gz" in files:
                target_found = os.path.join(root, f"{target}.gz")
                break
        if target_found:
            csv_files.append(target_found)
        
    if not csv_files:
        logger.warning(f"在 {results_dir} 下未找到任何目标CSV文件")
        return
    
    logger.info(f"找到 {len(csv_files)} 个CSV文件")
    
    # 解析所有CSV文件
    all_results = []
    
    for csv_file in csv_files:
        try:
            csv_data = parse_transposed_csv(csv_file, logger)
            
            # 提取参数值
            # 首先尝试从文件名提取
            filename = os.path.basename(csv_file)
            param_value = extract_param_value_from_filename(filename, param_name)
            
            # 如果从文件名提取失败，尝试从CSV数据中提取
            if param_value is None:
                param_value = extract_param_from_csv_data(csv_data, param_name)
            
            # 如果还是提取不到，尝试从目录名提取
            if param_value is None:
                dir_name = os.path.basename(os.path.dirname(csv_file))
                param_value = extract_param_value_from_filename(dir_name, param_name)
            
            if param_value is None:
                logger.warning(f"无法从 {csv_file} 提取参数值，跳过")
                continue
            
            # 提取关键字段的值
            result_row = {
                'param_value': param_value,
                'csv_file': csv_file
            }
            
            # 提取所有关键字段
            for field in key_fields:
                if field in csv_data:
                    values = csv_data[field]
                    if values and len(values) > 0:
                        result_row[field] = values[0]
                else:
                    result_row[field] = None
            
            # 提取所有其他字段（用于完整记录）
            for field_name, values in csv_data.items():
                if field_name not in result_row and values and len(values) > 0:
                    result_row[field_name] = values[0]
            
            all_results.append(result_row)
        
        except Exception as e:
            logger.error(f"处理CSV文件失败: {csv_file}, 错误: {str(e)}")
            continue
    
    if not all_results:
        logger.warning("未提取到任何有效结果")
        return
    
    # 按参数值排序
    try:
        all_results.sort(key=lambda x: float(x['param_value']))
    except (ValueError, KeyError):
        # 如果无法转换为数字，按字符串排序
        all_results.sort(key=lambda x: str(x.get('param_value', '')))
    
    # 生成汇总表格
    logger.info(f"生成汇总表格: {output_file}")
    
    # 收集所有可能的字段名
    all_fields = set(['param_value', 'csv_file'])
    for result in all_results:
        all_fields.update(result.keys())
    
    # 确定输出字段顺序：param_value, csv_file, key_fields, 其他字段
    output_fields = ['param_value', 'csv_file']
    output_fields.extend(key_fields)
    other_fields = sorted([f for f in all_fields if f not in output_fields])
    output_fields.extend(other_fields)
    
    # 确保输出目录存在
    output_dir_path = os.path.dirname(output_file) if os.path.dirname(output_file) else '.'
    os.makedirs(output_dir_path, exist_ok=True)
    
    # 写入汇总 CSV
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=output_fields)
        writer.writeheader()
        writer.writerows(all_results)
    
    logger.info(f"汇总表格已生成: {output_file}, 共 {len(all_results)} 条记录")
    
    # 打印摘要
    logger.info("=" * 60)
    logger.info("分析摘要:")
    logger.info(f"  处理的CSV文件数: {len(csv_files)}")
    logger.info(f"  有效结果数: {len(all_results)}")
    logger.info(f"  参数名称: {param_name}")
    logger.info(f"  关键字段: {', '.join(key_fields)}")
    logger.info("=" * 60)

# ==================== 主函数 ====================
def main():
    """主函数"""
    # 加载配置
    config = load_yaml_config(CONFIG_YAML_PATH)
    
    scan_config = config.get('scan', {})
    analyze_config = config.get('analyze', {})
    
    # 从 scan.param_path 派生参数名称（统一使用同一个配置源）
    param_path = scan_config['param_path']
    param_name = generate_param_name_from_path(param_path)
    
    # 获取 runtime 名称用于组织输出
    runtime_name = Path(scan_config['base_runtime_config']).stem
    
    # 自动调整搜索路径到对应的子目录
    specific_results_dir = os.path.join(analyze_config['results_dir'], runtime_name)
    
    # 构造输出文件路径（包含 runtime 名称）
    base_output_file = analyze_config['output_file']
    output_dir_path = os.path.dirname(base_output_file) if os.path.dirname(base_output_file) else '.'
    final_output_file = os.path.join(output_dir_path, f"analysis_summary_{runtime_name}.csv")

    # 设置日志
    logger = setup_logging()
    
    logger.info("=" * 60)
    logger.info("开始结果分析")
    logger.info("=" * 60)
    
    try:
        analyze_results(
            results_dir=specific_results_dir,
            param_name=param_name,
            output_file=final_output_file,
            key_fields=analyze_config.get('key_fields', []),
            logger=logger
        )
        
        logger.info("=" * 60)
        logger.info("结果分析完成")
        logger.info("=" * 60)
    
    except Exception as e:
        logger.error(f"执行过程中发生错误: {str(e)}", exc_info=True)
        raise

if __name__ == "__main__":
    main()
```

File: automatic/config.yaml
```yaml
# 自动化参数扫描与分析系统配置文件

# 参数扫描配置
scan:
  # 基础runtime配置文件路径
  base_runtime_config: "./automatic/base/runtime_S3_8K_automatic_256P_dsa.json"
  # 基础系统配置文件路径（如果param_path指向系统配置中的参数）
  base_sys_config: "./configs/260129SOW/npu/SOW_S3_POR.json"
  # 要测试的参数路径，支持：
  # - 简单路径：如 "mem1.GiB"
  # - 数组索引路径：如 "networks[0].bandwidth"
  # 注意：此值同时用于扫描和分析，会自动转换为文件名格式（如 "mem1.GiB" -> "mem1_GiB"）
  param_path: "mem1.GiB"
  
  # 参数生成模式配置
  param_mode:
    # 格式类型：single（单个数值）、pair（相同值数组如[1,1]）或 pair_null_first（[null, v] 仅修改第二个值）
    format: single
    # 数值类型：arithmetic（等差数列）或 power_of_2（2的幂次）
    value_type: arithmetic
    # arithmetic 模式参数
    start: 1
    end: 64
    step: 1
    # power_of_2 模式参数
    start_power: 0
    end_power: 10
  
  # 输出目录
  output_dir: "./automatic/test_results"
  # 生成的配置文件保存目录
  generated_configs_dir: "./automatic/generated_configs"

# 运行配置
run:
  # 仿真命令模板，{config_file}会被替换为实际配置文件路径
  command: "python3 run.py -c"
  # 运行日志文件路径
  log_file: "./batch_run.log"
  # 是否清理临时文件（生成的配置文件）
  cleanup_temp: false
  # 是否在每次运行后立即清理（false表示所有运行完成后统一清理）
  cleanup_after_run: false

# 分析配置
analyze:
  # 结果目录（扫描此目录下的所有CSV文件）
  results_dir: "./automatic/test_results"
  # 汇总分析输出文件
  output_file: "./automatic/analysis_summary.csv"
  # 需要提取的关键字段列表
  key_fields:
    - "decoder_throughput(token/s)"
    - "decoder_throughput_per_npu(token/s)"

```

File: automatic/common.py
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
共享工具模块
提供配置加载、日志设置等通用功能
"""

import os
import yaml
import logging

# ==================== 配置 ====================
# YAML配置文件路径（相对于运行目录）
CONFIG_YAML_PATH = "./automatic/config.yaml"

# ==================== 日志设置 ====================
def setup_logging(log_file=None):
    """
    设置日志
    
    Args:
        log_file: 可选的日志文件路径。如果提供，同时输出到文件和控制台；否则仅输出到控制台。
    
    Returns:
        logger: 配置好的日志对象
    """
    handlers = [logging.StreamHandler()]
    
    if log_file:
        handlers.append(logging.FileHandler(log_file, encoding='utf-8'))
    
    logging.basicConfig(
        level=logging.INFO,
        format='[%(asctime)s] %(levelname)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        handlers=handlers
    )
    return logging.getLogger(__name__)

# ==================== YAML配置加载 ====================
def load_yaml_config(config_file=None):
    """
    加载YAML配置文件
    
    Args:
        config_file: 配置文件路径，默认使用 CONFIG_YAML_PATH
    
    Returns:
        dict: 解析后的配置字典
    """
    if config_file is None:
        config_file = CONFIG_YAML_PATH
        
    if not os.path.exists(config_file):
        raise FileNotFoundError(f"配置文件不存在: {config_file}")
    
    with open(config_file, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    return config

# ==================== 参数名称工具 ====================
def generate_param_name_from_path(param_path):
    """
    从参数路径生成参数名称（用于文件名）
    
    将 "mem1.GiB" 转换为 "mem1_GiB"
    将 "networks[0].bandwidth" 转换为 "networks_0_bandwidth"
    
    Args:
        param_path: 参数路径字符串
    
    Returns:
        str: 适合用于文件名的参数名称
    """
    name = param_path.replace('.', '_').replace('[', '_').replace(']', '')
    return name

def format_value_for_filename(value):
    """
    将参数值转换为适合文件名的格式
    
    Args:
        value: 参数值（可能是数值、字符串或列表）
    
    Returns:
        str: 适合用于文件名的字符串
    
    Examples:
        1 -> "1"
        [1, 1] -> "1_1"
        "[1,1]" -> "1_1"
        [None, 50] -> "50"
    """
    if isinstance(value, list):
        # Python list 对象，过滤掉 None
        valid_parts = [str(v) for v in value if v is not None]
        return '_'.join(valid_parts)
    elif isinstance(value, str) and value.startswith('['):
        # 字符串格式的列表，如 "[1,1]" 或 "[null, 50]"
        inner = value.strip('[]')
        parts = [p.strip() for p in inner.split(',')]
        # 过滤掉 null/None 字符串
        valid_parts = [p for p in parts if p.lower() != 'null' and p != 'None']
        return '_'.join(valid_parts)
    else:
        return str(value)

def parse_csv_value(value_str):
    """
    解析 CSV 中的值字符串
    
    Args:
        value_str: CSV 中读取的字符串值
    
    Returns:
        解析后的值（int、float、list 或原始字符串）
    
    Examples:
        "1" -> 1
        "1.5" -> 1.5
        "[1,1]" -> [1, 1]
        "[null, 50]" -> [None, 50]
    """
    value_str = value_str.strip()
    
    # 检查是否为列表格式
    if value_str.startswith('[') and value_str.endswith(']'):
        inner = value_str[1:-1]
        parts = [p.strip() for p in inner.split(',')]
        # 尝试转换为数值
        result = []
        for p in parts:
            if p.lower() == 'null':
                result.append(None)
                continue
                
            try:
                result.append(int(p))
            except ValueError:
                try:
                    result.append(float(p))
                except ValueError:
                    result.append(p)
        return result
    
    # 尝试转换为整数
    try:
        return int(value_str)
    except ValueError:
        pass
    
    # 尝试转换为浮点数
    try:
        return float(value_str)
    except ValueError:
        pass
    
    # 保持原始字符串
    return value_str


```

File: automatic/generate_params.py
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
参数列表生成脚本
功能：从 config.yaml 读取参数配置，生成 param_list.csv
"""

import os
import csv
from common import load_yaml_config, CONFIG_YAML_PATH

def generate_arithmetic_values(start, end, step):
    """
    生成等差数列
    
    Args:
        start: 起始值
        end: 结束值（包含）
        step: 步长
    
    Returns:
        list: 数值列表
    """
    values = []
    current = start
    while current <= end:
        values.append(current)
        current += step
    return values

def generate_power_of_2_values(start_power, end_power):
    """
    生成2的幂次数列
    
    Args:
        start_power: 起始幂次
        end_power: 结束幂次（包含）
    
    Returns:
        list: 数值列表，如 [1, 2, 4, 8, ...]
    """
    return [2**i for i in range(start_power, end_power + 1)]

def format_value(value, format_type):
    """
    根据格式类型包装数值
    
    Args:
        value: 原始数值
        format_type: 格式类型 ('single' 或 'pair')
    
    Returns:
        格式化后的值
    """
    if format_type == 'single':
        return value
    elif format_type == 'pair':
        return [value, value]
    elif format_type == 'pair_null_first':
        return [None, value]
    else:
        raise ValueError(f"不支持的格式类型: {format_type}")

def value_to_csv_string(value):
    """
    将值转换为 CSV 字符串格式
    
    Args:
        value: 值（可能是数值或列表）
    
    Returns:
        str: CSV 中存储的字符串
    """
    if isinstance(value, list):
        # 列表格式：[1,1] 不带引号，None 转换为 null
        parts = []
        for v in value:
            if v is None:
                parts.append('null')
            else:
                parts.append(str(v))
        return '[' + ','.join(parts) + ']'
    else:
        return str(value)

def main():
    """主函数"""
    # 加载配置
    config = load_yaml_config(CONFIG_YAML_PATH)
    scan_config = config.get('scan', {})
    param_mode = scan_config.get('param_mode', {})
    
    # 获取格式和数值类型
    format_type = param_mode.get('format', 'single')
    value_type = param_mode.get('value_type', 'arithmetic')
    
    print(f"参数生成模式: format={format_type}, value_type={value_type}")
    
    # 生成数值列表
    if value_type == 'arithmetic':
        start = param_mode.get('start', 1)
        end = param_mode.get('end', 10)
        step = param_mode.get('step', 1)
        raw_values = generate_arithmetic_values(start, end, step)
        print(f"等差数列: start={start}, end={end}, step={step}")
    elif value_type == 'power_of_2':
        start_power = param_mode.get('start_power', 0)
        end_power = param_mode.get('end_power', 10)
        raw_values = generate_power_of_2_values(start_power, end_power)
        print(f"2的幂次: 2^{start_power} 到 2^{end_power}")
    else:
        raise ValueError(f"不支持的数值类型: {value_type}")
    
    # 格式化值
    formatted_values = [format_value(v, format_type) for v in raw_values]
    
    print(f"生成 {len(formatted_values)} 个参数值")
    
    # 输出 CSV 文件路径（与 config.yaml 同目录）
    config_dir = os.path.dirname(CONFIG_YAML_PATH) if os.path.dirname(CONFIG_YAML_PATH) else '.'
    csv_path = os.path.join(config_dir, 'param_list.csv')
    
    # 写入 CSV（手动写入避免自动引号）
    with open(csv_path, 'w', newline='', encoding='utf-8') as f:
        f.write('value\n')  # 表头
        for value in formatted_values:
            f.write(value_to_csv_string(value) + '\n')
    
    print(f"参数列表已保存到: {csv_path}")
    
    # 打印前几个值预览
    preview_count = min(5, len(formatted_values))
    print(f"预览前 {preview_count} 个值:")
    for i in range(preview_count):
        print(f"  {value_to_csv_string(formatted_values[i])}")
    if len(formatted_values) > preview_count:
        print(f"  ... 共 {len(formatted_values)} 个值")

if __name__ == "__main__":
    main()

```

File: automatic/run_param_scan.py
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
参数扫描与批量运行脚本
功能：根据参数范围生成多个配置文件，并批量运行仿真
"""

import os
import json
import csv
import subprocess
from datetime import datetime
from pathlib import Path

from common import (load_yaml_config, setup_logging, generate_param_name_from_path, 
                    format_value_for_filename, parse_csv_value, CONFIG_YAML_PATH)

# ==================== 参数路径解析 ====================
def parse_param_path(config, param_path):
    """
    解析参数路径，返回最后一级的key和父对象
    
    Args:
        config: 配置字典
        param_path: 参数路径，如 'mem1.GiB' 或 'networks[0].bandwidth'
    
    Returns:
        (last_key, parent_obj): 最后一级的key和父对象
    """
    parts = param_path.split('.')
    current = config
    
    # 遍历到倒数第二级
    for i, part in enumerate(parts[:-1]):
        if '[' in part:
            # 处理数组索引，如 "networks[0]"
            key, index_str = part.split('[')
            index = int(index_str.rstrip(']'))
            if key not in current:
                raise KeyError(f"路径不存在: {'.'.join(parts[:i+1])}")
            if not isinstance(current[key], list):
                raise TypeError(f"{'.'.join(parts[:i+1])} 不是数组")
            if index >= len(current[key]):
                raise IndexError(f"数组索引超出范围: {'.'.join(parts[:i+1])}[{index}]")
            current = current[key][index]
        else:
            if part not in current:
                raise KeyError(f"路径不存在: {'.'.join(parts[:i+1])}")
            current = current[part]
    
    return parts[-1], current

def set_param_value(config, param_path, value):
    """设置参数值"""
    last_key, parent = parse_param_path(config, param_path)
    
    # 处理包含 None 的列表（部分更新模式）
    if isinstance(value, list) and None in value:
        current_val = parent.get(last_key)
        # 只有当当前值也是列表且长度一致时才进行合并
        if isinstance(current_val, list) and len(current_val) == len(value):
            merged_value = []
            for new_v, old_v in zip(value, current_val):
                # 如果新值为 None，保留旧值；否则使用新值
                merged_value.append(new_v if new_v is not None else old_v)
            parent[last_key] = merged_value
            return

    parent[last_key] = value

# ==================== CSV 参数读取 ====================
def read_param_csv(csv_path, logger):
    """
    从 CSV 文件读取参数值列表
    
    Args:
        csv_path: CSV 文件路径
        logger: 日志对象
    
    Returns:
        list: 参数值列表
    """
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"参数列表文件不存在: {csv_path}")
    
    values = []
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            value_str = row.get('value', '')
            if value_str:
                values.append(parse_csv_value(value_str))
    
    logger.info(f"从 CSV 读取 {len(values)} 个参数值")
    return values

# ==================== 配置文件生成 ====================
def generate_configs(base_runtime_config, base_sys_config_path, param_path, 
                     output_dir, generated_configs_dir, logger):
    """
    生成多个配置文件
    
    Args:
        base_runtime_config: 基础runtime配置文件路径
        base_sys_config_path: 基础系统配置文件路径
        param_path: 参数路径
        output_dir: 输出目录
        generated_configs_dir: 生成的配置文件目录
        logger: 日志对象
    
    Returns:
        list: 生成的配置文件路径列表
    """
    # 读取基础runtime配置
    if not os.path.exists(base_runtime_config):
        raise FileNotFoundError(f"基础runtime配置文件不存在: {base_runtime_config}")
    
    with open(base_runtime_config, 'r', encoding='utf-8') as f:
        runtime_config = json.load(f)
    
    # 读取基础系统配置
    if not os.path.exists(base_sys_config_path):
        raise FileNotFoundError(f"基础系统配置文件不存在: {base_sys_config_path}")
    
    with open(base_sys_config_path, 'r', encoding='utf-8') as f:
        base_sys_config = json.load(f)
    
    # 提取原始 runtime 文件名（不含后缀）作为组织标识
    runtime_name = Path(base_runtime_config).stem
    
    # 创建专属于该 runtime 的配置文件存放目录
    config_subdir = os.path.join(generated_configs_dir, runtime_name)
    os.makedirs(config_subdir, exist_ok=True)
    
    # 设定结果输出的基础子目录：test_results/[runtime_name]/
    results_base_dir = os.path.join(output_dir, runtime_name)

    # 从 CSV 读取参数值列表
    config_dir = os.path.dirname(CONFIG_YAML_PATH) if os.path.dirname(CONFIG_YAML_PATH) else '.'
    param_csv_path = os.path.join(config_dir, 'param_list.csv')
    param_values = read_param_csv(param_csv_path, logger)
    
    # 创建输出目录
    os.makedirs(generated_configs_dir, exist_ok=True)
    os.makedirs(output_dir, exist_ok=True)
    
    # 生成参数名称（用于文件名）
    param_name = generate_param_name_from_path(param_path)
    
    # 获取原始硬件名称
    original_name = base_sys_config.get('name', 'System')
    
    generated_files = []
    
    # 为每个参数值生成配置
    for param_value in param_values:
        # 创建runtime配置的副本
        new_runtime_config = json.loads(json.dumps(runtime_config))
        
        # 将参数值转换为文件名格式
        value_for_filename = format_value_for_filename(param_value)
        
        # 为每个参数组合创建独立的输出文件夹
        # 例如：test_results/runtime/config_mem1_GiB_1_1/
        sub_dir_name = f"config_{param_name}_{value_for_filename}"
        specific_output_path = os.path.join(results_base_dir, sub_dir_name)
        os.makedirs(specific_output_path, exist_ok=True)
        
        # 强制修改所有部署形态中的 output 字段，确保数据不覆盖
        for deploy_mode in new_runtime_config.keys():
            if isinstance(new_runtime_config[deploy_mode], dict) and \
               deploy_mode in ['pd-split-request-optimal', 'pd-fusion']:
                new_runtime_config[deploy_mode]['output'] = specific_output_path

        # 确定参数路径指向的是runtime配置还是系统配置
        is_sys_config_param = param_path.startswith('sys_list') or \
                              param_path.startswith('networks') or \
                              param_path.startswith('mem') or \
                              param_path.startswith('matrix') or \
                              param_path.startswith('vector')
        
        if is_sys_config_param:
            # 参数在系统配置中，需要修改系统配置文件
            new_sys_config = json.loads(json.dumps(base_sys_config))
            
            # 修改系统配置中的参数值
            try:
                set_param_value(new_sys_config, param_path, param_value)
            except (KeyError, TypeError, IndexError) as e:
                logger.warning(f"无法在系统配置中设置参数 {param_path}: {e}")
                # 尝试在runtime配置的sys_list中修改
                for deploy_mode in new_runtime_config.keys():
                    if deploy_mode in ['pd-split-request-optimal', 'pd-fusion']:
                        sys_list = new_runtime_config[deploy_mode].get('sys_list', [])
                        if isinstance(sys_list, list) and len(sys_list) > 0:
                            for sys_item in sys_list:
                                if isinstance(sys_item, list):
                                    # PD分离模式：二维数组
                                    for sys_path in sys_item:
                                        if os.path.exists(sys_path):
                                            with open(sys_path, 'r', encoding='utf-8') as sf:
                                                sys_cfg = json.load(sf)
                                            set_param_value(sys_cfg, param_path, param_value)
                                            sys_cfg['name'] = f"{original_name}_{param_name}_{value_for_filename}"
                                            new_sys_path = os.path.join(
                                                config_subdir,
                                                f"sys_{param_name}_{value_for_filename}_{os.path.basename(sys_path)}"
                                            )
                                            with open(new_sys_path, 'w', encoding='utf-8') as sf:
                                                json.dump(sys_cfg, sf, indent=2, ensure_ascii=False)
                                            sys_item[sys_item.index(sys_path)] = new_sys_path
                                else:
                                    # PD融合模式：一维数组或单个路径
                                    if isinstance(sys_item, str) and os.path.exists(sys_item):
                                        with open(sys_item, 'r', encoding='utf-8') as sf:
                                            sys_cfg = json.load(sf)
                                        set_param_value(sys_cfg, param_path, param_value)
                                        sys_cfg['name'] = f"{original_name}_{param_name}_{value_for_filename}"
                                        new_sys_path = os.path.join(
                                            config_subdir,
                                            f"sys_{param_name}_{value_for_filename}_{os.path.basename(sys_item)}"
                                        )
                                        with open(new_sys_path, 'w', encoding='utf-8') as sf:
                                            json.dump(sys_cfg, sf, indent=2, ensure_ascii=False)
                                        if isinstance(sys_list, list):
                                            idx = sys_list.index(sys_item)
                                            sys_list[idx] = new_sys_path
            else:
                # 修改硬件名称
                new_sys_config['name'] = f"{original_name}_{param_name}_{value_for_filename}"
                
                # 保存修改后的系统配置
                new_sys_config_path = os.path.join(
                    config_subdir,
                    f"sys_{param_name}_{value_for_filename}_{os.path.basename(base_sys_config_path)}"
                )
                with open(new_sys_config_path, 'w', encoding='utf-8') as f:
                    json.dump(new_sys_config, f, indent=2, ensure_ascii=False)
                
                # 更新runtime配置中的sys_list路径
                for deploy_mode in new_runtime_config.keys():
                    if deploy_mode in ['pd-split-request-optimal', 'pd-fusion']:
                        sys_list = new_runtime_config[deploy_mode].get('sys_list', [])
                        if isinstance(sys_list, list):
                            for i, sys_item in enumerate(sys_list):
                                if isinstance(sys_item, list):
                                    for j, sys_path in enumerate(sys_item):
                                        if sys_path == base_sys_config_path:
                                            sys_list[i][j] = new_sys_config_path
                                elif sys_item == base_sys_config_path:
                                    sys_list[i] = new_sys_config_path
        else:
            # 参数在runtime配置中
            try:
                set_param_value(new_runtime_config, param_path, param_value)
            except (KeyError, TypeError, IndexError) as e:
                logger.error(f"无法在runtime配置中设置参数 {param_path}: {e}")
                raise
        
        # 将生成的配置文件保存在子目录下
        config_filename = f"runtime_{param_name}_{value_for_filename}.json"
        config_filepath = os.path.join(config_subdir, config_filename)
        
        with open(config_filepath, 'w', encoding='utf-8') as f:
            json.dump(new_runtime_config, f, indent=2, ensure_ascii=False)
        
        generated_files.append(config_filepath)
        logger.info(f"生成配置文件: {config_filepath}")
    
    return generated_files

# ==================== 批量运行 ====================
def run_simulations(config_files, command_template, cleanup_temp, cleanup_after_run, logger):
    """
    批量运行仿真命令
    
    Args:
        config_files: 配置文件路径列表
        command_template: 命令模板，如 "python3 run.py -c"
        cleanup_temp: 是否清理临时文件
        cleanup_after_run: 是否在每次运行后立即清理
        logger: 日志对象
    """
    total = len(config_files)
    success_count = 0
    fail_count = 0
    
    logger.info(f"开始批量运行，共 {total} 个配置")
    
    for i, config_file in enumerate(config_files, 1):
        logger.info(f"[{i}/{total}] 开始运行配置: {config_file}")
        
        start_time = datetime.now()
        
        try:
            # 构建完整命令
            command = f"{command_template} {config_file}"
            logger.info(f"执行命令: {command}")
            
            # 执行命令
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                check=False
            )
            
            elapsed = (datetime.now() - start_time).total_seconds()
            
            if result.returncode == 0:
                logger.info(f"配置运行完成: {config_file}, 耗时: {elapsed:.1f}s")
                success_count += 1
            else:
                logger.error(f"配置运行失败: {config_file}, 耗时: {elapsed:.1f}s")
                logger.error(f"错误输出: {result.stderr}")
                fail_count += 1
            
            # 如果设置了每次运行后清理，且运行成功
            if cleanup_after_run and result.returncode == 0:
                if os.path.exists(config_file):
                    os.remove(config_file)
                    logger.info(f"已清理临时配置文件: {config_file}")
        
        except Exception as e:
            elapsed = (datetime.now() - start_time).total_seconds()
            logger.error(f"配置运行异常: {config_file}, 耗时: {elapsed:.1f}s, 错误: {str(e)}")
            fail_count += 1
    
    logger.info(f"批量运行完成: 成功 {success_count}, 失败 {fail_count}, 总计 {total}")
    
    # 如果设置了清理临时文件，且不是每次运行后清理
    if cleanup_temp and not cleanup_after_run:
        logger.info("开始清理所有临时配置文件...")
        for config_file in config_files:
            if os.path.exists(config_file):
                os.remove(config_file)
                logger.info(f"已清理临时配置文件: {config_file}")
        
        # 清理生成的系统配置文件
        config_dir = os.path.dirname(config_files[0]) if config_files else None
        if config_dir and os.path.exists(config_dir):
            for file in os.listdir(config_dir):
                if file.startswith('sys_'):
                    file_path = os.path.join(config_dir, file)
                    os.remove(file_path)
                    logger.info(f"已清理临时系统配置文件: {file_path}")

# ==================== 主函数 ====================
def main():
    """主函数"""
    # 加载配置
    config = load_yaml_config(CONFIG_YAML_PATH)
    
    scan_config = config.get('scan', {})
    run_config = config.get('run', {})
    
    # 设置日志
    log_file = run_config.get('log_file', './batch_run.log')
    logger = setup_logging(log_file)
    
    logger.info("=" * 60)
    logger.info("开始参数扫描与批量运行")
    logger.info("=" * 60)
    
    try:
        # 生成配置文件
        generated_files = generate_configs(
            base_runtime_config=scan_config['base_runtime_config'],
            base_sys_config_path=scan_config['base_sys_config'],
            param_path=scan_config['param_path'],
            output_dir=scan_config['output_dir'],
            generated_configs_dir=scan_config['generated_configs_dir'],
            logger=logger
        )
        
        if not generated_files:
            logger.warning("未生成任何配置文件")
            return
        
        # 批量运行
        run_simulations(
            config_files=generated_files,
            command_template=run_config.get('command', 'python3 run.py -c'),
            cleanup_temp=run_config.get('cleanup_temp', True),
            cleanup_after_run=run_config.get('cleanup_after_run', False),
            logger=logger
        )
        
        logger.info("=" * 60)
        logger.info("参数扫描与批量运行完成")
        logger.info("=" * 60)
    
    except Exception as e:
        logger.error(f"执行过程中发生错误: {str(e)}", exc_info=True)
        raise

if __name__ == "__main__":
    main()
```

